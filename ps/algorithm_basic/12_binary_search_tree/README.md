# Binary Search Trees

## 들어가며

- 배열은 마지막 값 조작을 O(1)만에 할 수 있다.
- 연결 리스트는 첫번째 값 조작을 O(1)만에 할 수 있다
- 둘 다 임의의 값을 조작하는 것은 O(N)이 걸린다.
- 만약 배열이 정렬되어있다면? O(log N)이라는 로그함수적 시간 복잡도 내로 값을 찾을 수 있다 → 이것이 이진 탐색의 기본

## 트리?

- 방향없는 G(V, E) 형식의 그래프
- 회전이 없음(acyclic)

## 이진 검색트리?

### 구조

- 자식의 최대갯수는 2개
- 왼쪽자식은 부모노드보다 값이 작음
- 오른쪽 자식은 부모노드보다 값이 큼

### 특징

- 제대로된 값을 찾기 전에는 모든 선택이 절반만큼 사라진다(!)
- 그래서 로그함수적 시간복잡도를 가짐
- 균형이 깨지면 상기 언급한 "절반"의 의미가 퇴색된다 -> O(N)만큼의 시간이 소요될 수 있다.
- 항상 균형을 지키는 트리가 대두됨(AVL 트리, 레드/블랙 트리)

## 이진 검색트리의 연산

이걸 까먹으면 안됨!

- 자식의 최대갯수는 2개
- 왼쪽자식은 부모노드보다 값이 작음
- 오른쪽 자식은 부모노드보다 값이 큼

### 추가

루트부터 타고가서 없애기

### `max()`

오른쪽 끝 리프노드로 순회(traversal)

### `min()`

왼쪽 끝 리프노드로 순회

### 삭제

#### 리프노드 삭제?

그냥 `None` 저장하기

#### 자식이 둘 있는 노드 삭제

1. 루트 삭제의 경우
   1. 왼쪽 서브노드의 가장 큰값과 오른쪽 서브노드의 가장 작은값을 비교
   2. 값을 옮기고도 성립되는 트리를 만들기 위해 루트와 1-1에서 고른 값을 스왑
   3. 해당 리프노드 제거

### 순회

모든 이진트리 내의 값을 O(N)만에 "순회"하는 방법을 의미한다.

#### 전위순회(pre-order traversal)

왼쪽-중앙-오른쪽 순으로 순회

#### 중위순회(in-order traversal)

중앙-왼쪽-오른쪽 순으로 순회

#### 후위순회(post-order traversal)

왼쪽-오른쪽-중앙 순으로 순회

### 성능

|            | 일반적인 경우 | 최악의 경우 |
| ---------- | ------------- | ----------- |
| 시간복잡도 | O(N)          | O(N)        |
| 삽입       | O(log N)      | O(N)        |
| 삭제       | O(log N)      | O(N)        |
| 검색       | O(log N)      | O(N)        |

## 트리의 쓰임새

- 구조적데이터는 어지간해선 트리
  - OS 내부구현, DB 내부구현에도 쓰임
  - 게임트리에도 쓰임
  - decision tree나 boosting에도 쓰임(ML)
