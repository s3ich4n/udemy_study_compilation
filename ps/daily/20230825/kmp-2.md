# KMP 알고리즘

패턴과 본문 내의 문자열 중 다음 단계의 검색에서 활용할 수 있는 '정보'를 활용하여 선형횟수만큼 패턴일치하는 문자열을 찾아냄.

## 알고리즘 상세

1. 본문과 패턴이 일치하는지 본다.
2. 패턴의 어디까지 일치하는지 찾는다
    1. 그 전까지 본문과 일치했던 패턴을 찾는다
    2. 경계를 찾는다 (경계? 서로 일치하는 접두부와 접미부가 있는 경우)
3. 패턴 전체를 오른쪽으로 민다.
    1. 일치하던 부분의 길이 - 경계의 길이

## 알고리즘 이해 (1) - 경계 정보를 미리 계산하기

(`BAABAABA`로도 해보자.)

`BAABABBA` 라는 패턴에 대해, 불일치가 일어나는 문자가 n번째인 경우를 살펴보자.

1. 첫 번째 - 항상 -1로 두자.
    1. 경계가 없을 때의 경계로 너비로 사용

2. 두 번째는 - 0
    - B
    - ... 경계 없음!

3. 세 번째는 - 0
    - B
    - BA
    - ... 경계 없음!

4. 네 번째는 - 0
    - B
    - BA
    - BAA
    - ... 경계 없음!

5. 다섯 번째는 - 1
    - B
    - BA
    - BAA
    - BAAB -> 이 문자열의 경계가 **B**

6. 여섯 번째는 - 2
    - B
    - BA
    - BAA
    - BAAB
    - BAABA -> 이 문자열의 경계가 **BA**

7. 일곱 번째는 - 1
    - B
    - BA
    - BAA
    - BAAB
    - BAABA
    - BAABAB -> 이 문자열의 경계가 **B**

8. 여덟 번째는 - 2
    - B
    - BA
    - BAA
    - BAAB
    - BAABA
    - BAABAB
    - BAABABA -> 이 문자열의 경계가 **BA**

9. 9번째의 존재여부?
    - 본문 내의 문재열이 패턴과 일치하지만 이어서 탐색하고 싶은 경우 사용.
    - E.g.,
        - 패턴 전체와 일치하는 부분을 찾았음.
        - 그 부분 뒤에 이어지는 본문의 문자가 패턴의 첫 문자와 일치하지 않는 경우
    - 아홉 번째는 - 3
        - B
        - BA
        - BAA
        - BAAB
        - BAABA
        - BAABAB
        - BAABABA
        - BAABABAA -> 이 문자열의 경계가 **BAA**

## 알고리즘 이해 (2) - 이동거리

> $이동 거리 = 일치 접두부의 길이 + 최대 경계 너비$

`BAABAA` 라는 문자열이 있고, 상기 패턴을 이용할 경우?

1. `BAABA`까지 일치, `BAABAA` 패턴 불일치
2. 이동 거리(_mov_) = 일치 접두부의 길이(`5`) + 최대 경계 너비(`2`)
    - $mov = 5 - 2 = 3$

## 구현

### 어프로치 - s3ich4n 식

1. 경계정보 검색하기
2. 문자열에서 패턴만큼 읽기

## 보다 나은 접근법

해당 [링크](https://hwlang.de/algorithmen/pattern/kmpen.htm) 를 보고 학습하자!

### 상세

구현코드 -> kmp_003.py

엡실론(`ε`)값은 빈 문자열이다.

### 정리, 증명, 정의

- 정리: `r`과 `s` 라는 문자열은 `x`의 경계값이라고 하자. `|r| < |s|` 일 때, `r`은 `s`의 경계다.
- 증명: `r`은 `x`안에 있고, `r`은 `s` 안에 있다. 상기 조건에 따라 `r`은 `s`의 경계다
    - ![경계 r, x의 문자열 s](https://hwlang.de/algorithmen/pattern/rand.gif)
- 정의: `x` 문자열에 `a` 라는 내용이 있다고 하자. `ra`가 `xa` 의 테두리인 경우 x 의 테두리 `r`은 `a` 로 **확장** 될 수 있다. (이 확장이라는 개념이 계속 나옴!)
    - ![테두리 확장](https://hwlang.de/algorithmen/pattern/rand2.gif)
- 전처리 단계에서는 `m + 1` 길이의 `b` 배열을 만든다. `b[i]` 는 패턴의 길이 `i` suffix의 가장 넓은 경계 너비가 포함된다(`i = 0, ..., m`)
- 길이 `0`인 접두사 ε에는 경계가 없으므로, `b[0] = -1` 로 설정한다.
- `b[0], ..., b[i]` 값이 이미 알려져 있다면, `b[i+1]` 은 접두어 $p_0, ..., p_{i-1}$ 의 경계가 가능한지 확인하여 계산된다. 이는 $p_{b[i]} = p_i$ 인 경우를 의미한다.
    - ![너비 b[i]의 테두리가 있는 패턴의 길이 i 접두사](https://hwlang.de/algorithmen/pattern/rand4.gif)
- 검사할 경계는 `b[i]`, `b[b[i]]` 등의 값에서 내림차순으로 얻어진다

### 전처리 알고리즘?

- 전처리 알고리즘은 이러한 값을 취하는 변수 `j`가 있는 루프로 구성된다. $p_j = p_i$ 인 경우, 너비 `j`의 경계는 **확장**될 수 있다. 그렇지 않다면 다음으로 넓은 경계를 검사한다. 루프는 늦어도 경계를 확장할 수 없는 경우 종료된다(`j = -1`).

- 각 경우에 `j++` 문으로 `j`를 증가시킨 후 `j`는 $p_0, ..., p_i$ 의 가장 넓은 테두리의 너비이다. 이 값은 `b[i+1]` 에 기록된다(`i++` 문으로 `i`를 증가시킨 후 `b[i]`에 기록된다).

이 내용이 `kmp_003.py`의 `preprocess_kmp` 함수이다.

```python
def preprocess_kmp(pattern: str) -> List[int]:
    """ 상기 정리, 증명, 정의를 활용하여, KMP에 사용할 문자열을 생성한다.

    Args:
        pattern (str): 문자열 패턴

    Returns:
        List[int]: KMP 탐색에 사용할 패턴의 스킵값
    """
    i = 0
    j = -1

    # m + 1 만큼의 배열을 만들고, -1로 초기화
    b = [-1 for _ in range(len(pattern) + 1)]

    # pattern 문자열 처음부터 끝까지 탐색한다.
    while i < len(pattern):
        # 확장할 수 없는 경우에 대해 찾는다
        #   `b[0], ..., b[i]` 값이 이미 알려져 있다면,
        #   `b[i+1]` 은 접두어 $p_0, ..., p_{i-1}$ 의 경계가 가능한지 확인하여 계산된다.
        #   이는 $p_{b[i]} = p_i$ 인 경우를 의미한다.
        while j >= 0 and pattern[i] != pattern[j]:
            j = b[j]

        # 각 경우에 j 증가 후 가장 넓은 테두리의 너비를 기록한다
        #   부분 일치 테이블 값을 저장하고,
        #   패턴 문자열을 끝까지 탐색한 후에는
        #   부분 일치 테이블을 반환한다.
        i += 1
        j += 1
        b[i] = j

    return b
```
