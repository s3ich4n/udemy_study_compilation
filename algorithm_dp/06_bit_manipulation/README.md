# Bit manipulation

컴퓨터는 명시적인 이진 값을 이해할 수 있다. 모든 데이터는 0이냐 1이냐 하는 값들이 어떻게 기록되는지에 대한 약속이기 때문이다.

E.g., `27`이란 값도 `0x11011` 이란 이진값이다.

## 바이너리 연산자

### AND

- 두 값이 참일 때 참을 리턴

### OR

- 한 값이라도 참이면 참을 리턴

### NOT

- 참/거짓을 반대로 하여 리턴

### XOR

- 두 값이 서로 다르면 참을 리턴

## 바이너리 시프트 연산자

### `<<`

- 1바이트씩 좌측으로 밀어냄(shifted). 끝에는 0이 붙음

### `>>`

- 1바이트씩 우측으로 밀어냄(shifted). 끝에는 0이 붙음

## 예시코드 몇가지

### 바이너리 길이를 구하려면?

```python
# O(log N) 정도가 걸린다
def solution(n):
    count = 0

    while n > 0:
        counter += 1
        n = n >> 1

    return counter

solution(16)
```

### 홀짝 판별?

`x = lambda x: True if x % 2 == 0 else False` 으로도 판별할 수 있지만...

`홀수 ^ 1` 을 하면 `홀수-1`이 나오고, `짝수 ^ 1`을 하면 `짝수+1`이 나온다. 그걸 노린 수식이다.

`is_even_or_odd = lambda x: x ^ 1 == x + 1` (짝수인지 판별)

O(1) 정도 걸린다. modular 연산으로도 O(1)이긴 한데 이 트릭을 알고있자.

## 러시아 농노 문제

두 수의 곱을 곱하는 문제. 뜬금없게도 여기서 쓰인다고? 일단 살펴보자.

"곱셈을 쓰지 말고 두 수의 곱을 구하시오."같은 제한조건이 걸려있을 때 사용하는 해답이다.

```python
def solution(a, b):
    result = 0

    while b > 0:
        # b값이 홀수가 되면?
        if b ^ 1 == b - 1:
            result = result + a

        a <<= 1
        b >>= 1

    return result
```

## 러시아 농노 문제 (cont'd)

재귀로도 풀 수 있다.
